"""
pip._vendor is for vendoring dependencies of pip to prevent needing pip to
depend on something external.

Files inside of pip._vendor should be considered immutable and should only be
updated to versions from upstream.
"""
from __future__ import absolute_import

import glob
import os.path
import sys

<<<<<<< HEAD
=======
# Downstream redistributors which have debundled our dependencies should also
# patch this value to be true. This will trigger the additional patching
# to cause things like "six" to be available as pip.
DEBUNDLED = False
>>>>>>> fe78b6a1d44e13e192ee18b9a76be07cff10532e

# By default, look in this directory for a bunch of .whl files which we will
# add to the beginning of sys.path before attempting to import anything. This
# is done to support downstream re-distributors like Debian and Fedora who
# wish to create their own Wheels for our dependencies to aid in debundling.
WHEEL_DIR = os.path.abspath(os.path.dirname(__file__))

<<<<<<< HEAD
# Actually look inside of WHEEL_DIR to find .whl files and add them to the
# front of our sys.path.
sys.path = glob.glob(os.path.join(WHEEL_DIR, "*.whl")) + sys.path


class VendorAlias(object):

    def __init__(self, package_names):
        self._package_names = package_names
        self._vendor_name = __name__
        self._vendor_pkg = self._vendor_name + "."
        self._vendor_pkgs = [
            self._vendor_pkg + name for name in self._package_names
        ]

    def find_module(self, fullname, path=None):
        if fullname.startswith(self._vendor_pkg):
            return self

    def load_module(self, name):
        # Ensure that this only works for the vendored name
        if not name.startswith(self._vendor_pkg):
            raise ImportError(
                "Cannot import %s, must be a subpackage of '%s'." % (
                    name, self._vendor_name,
                )
            )
        if not (name == self._vendor_name or
                any(name.startswith(pkg) for pkg in self._vendor_pkgs)):
            raise ImportError(
                "Cannot import %s, must be one of %s." % (
                    name, self._vendor_pkgs
                )
            )

        # Check to see if we already have this item in sys.modules, if we do
        # then simply return that.
        if name in sys.modules:
            return sys.modules[name]

        # Check to see if we can import the vendor name
        try:
            # We do this dance here because we want to try and import this
            # module without hitting a recursion error because of a bunch of
            # VendorAlias instances on sys.meta_path
            real_meta_path = sys.meta_path[:]
            try:
                sys.meta_path = [
                    m for m in sys.meta_path
                    if not isinstance(m, VendorAlias)
                ]
                __import__(name)
                module = sys.modules[name]
            finally:
                # Re-add any additions to sys.meta_path that were made while
                # during the import we just did, otherwise things like
                # pip._vendor.six.moves will fail.
                for m in sys.meta_path:
                    if m not in real_meta_path:
                        real_meta_path.append(m)

                # Restore sys.meta_path with any new items.
                sys.meta_path = real_meta_path
        except ImportError:
            # We can't import the vendor name, so we'll try to import the
            # "real" name.
            real_name = name[len(self._vendor_pkg):]
            try:
                __import__(real_name)
                module = sys.modules[real_name]
            except ImportError:
                raise ImportError("No module named '%s'" % (name,))

        # If we've gotten here we've found the module we're looking for, either
        # as part of our vendored package, or as the real name, so we'll add
        # it to sys.modules as the vendored name so that we don't have to do
        # the lookup again.
        sys.modules[name] = module

        # Finally, return the loaded module
        return module


sys.meta_path.append(VendorAlias([
    "_markerlib", "cachecontrol", "certifi", "colorama", "distlib", "html5lib",
    "ipaddress", "lockfile", "packaging", "pkg_resources", "progress",
    "requests", "retrying", "six",
]))
=======

# Define a small helper function to alias our vendored modules to the real ones
# if the vendored ones do not exist. This idea of this was taken from
# https://github.com/kennethreitz/requests/pull/2567.
def vendored(modulename):
    vendored_name = "{0}.{1}".format(__name__, modulename)

    try:
        __import__(vendored_name, globals(), locals(), level=0)
    except ImportError:
        try:
            __import__(modulename, globals(), locals(), level=0)
        except ImportError:
            # We can just silently allow import failures to pass here. If we
            # got to this point it means that ``import pip._vendor.whatever``
            # failed and so did ``import whatever``. Since we're importing this
            # upfront in an attempt to alias imports, not erroring here will
            # just mean we get a regular import error whenever pip *actually*
            # tries to import one of these modules to use it, which actually
            # gives us a better error message than we would have otherwise
            # gotten.
            pass
        else:
            sys.modules[vendored_name] = sys.modules[modulename]
            base, head = vendored_name.rsplit(".", 1)
            setattr(sys.modules[base], head, sys.modules[modulename])


# If we're operating in a debundled setup, then we want to go ahead and trigger
# the aliasing of our vendored libraries as well as looking for wheels to add
# to our sys.path. This will cause all of this code to be a no-op typically
# however downstream redistributors can enable it in a consistent way across
# all platforms.
if DEBUNDLED:
    # Actually look inside of WHEEL_DIR to find .whl files and add them to the
    # front of our sys.path.
    sys.path[:] = glob.glob(os.path.join(WHEEL_DIR, "*.whl")) + sys.path

    # Actually alias all of our vendored dependencies.
    vendored("cachecontrol")
    vendored("colorama")
    vendored("distlib")
    vendored("html5lib")
    vendored("lockfile")
    vendored("six")
    vendored("six.moves")
    vendored("six.moves.urllib")
    vendored("packaging")
    vendored("packaging.version")
    vendored("packaging.specifiers")
    vendored("pkg_resources")
    vendored("progress")
    vendored("retrying")
    vendored("requests")
    vendored("requests.packages")
    vendored("requests.packages.urllib3")
    vendored("requests.packages.urllib3._collections")
    vendored("requests.packages.urllib3.connection")
    vendored("requests.packages.urllib3.connectionpool")
    vendored("requests.packages.urllib3.contrib")
    vendored("requests.packages.urllib3.contrib.ntlmpool")
    vendored("requests.packages.urllib3.contrib.pyopenssl")
    vendored("requests.packages.urllib3.exceptions")
    vendored("requests.packages.urllib3.fields")
    vendored("requests.packages.urllib3.filepost")
    vendored("requests.packages.urllib3.packages")
    vendored("requests.packages.urllib3.packages.ordered_dict")
    vendored("requests.packages.urllib3.packages.six")
    vendored("requests.packages.urllib3.packages.ssl_match_hostname")
    vendored("requests.packages.urllib3.packages.ssl_match_hostname."
             "_implementation")
    vendored("requests.packages.urllib3.poolmanager")
    vendored("requests.packages.urllib3.request")
    vendored("requests.packages.urllib3.response")
    vendored("requests.packages.urllib3.util")
    vendored("requests.packages.urllib3.util.connection")
    vendored("requests.packages.urllib3.util.request")
    vendored("requests.packages.urllib3.util.response")
    vendored("requests.packages.urllib3.util.retry")
    vendored("requests.packages.urllib3.util.ssl_")
    vendored("requests.packages.urllib3.util.timeout")
    vendored("requests.packages.urllib3.util.url")
>>>>>>> fe78b6a1d44e13e192ee18b9a76be07cff10532e
